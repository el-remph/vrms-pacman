#!/usr/bin/perl
use strict;
use warnings;
use feature qw(fc postderef unicode_strings);
#use open qw(:std :utf8);
use Data::Dumper;
use JSON;

die if @ARGV;

$/ = undef;
my $spdx_db = JSON->new->utf8->boolean_values(0, 1)->decode(<STDIN>);
my %result;

while (defined($_ = shift $spdx_db->{licenses}->@*)) {
	my %entry = ( name => $_->{name} );
	for my $field (qw(isOsiApproved isFsfLibre)) {
		$entry{$field} = $_->{$field} if defined $_->{$field};
	}
	$result{$_->{licenseId}} = \%entry;
}

# See notes on Trailingcomma in scancode-hack.pl
$Data::Dumper::Terse = $Data::Dumper::Indent = $Data::Dumper::Useqq = $Data::Dumper::Trailingcomma = 1;
$Data::Dumper::Quotekeys = 0;
$Data::Dumper::Sortkeys = sub {
	my @arr = sort { fc($a) cmp fc($b) } keys %{;shift};
	return \@arr;
};
$_ = Dumper(\%result);
undef %result;

print <<HEADER;
# Generated by $0 from SPDX list version $spdx_db->{licenseListVersion}

use strict;
use warnings;
package Licences::SPDX;

HEADER

# post-processing
s/^{/our %db = (/ or warn;
s/}$/);/ or warn;
s/^  "?+(.+?)"?+ => \{$/  "\\F$1" => {/gm or warn;

print;
